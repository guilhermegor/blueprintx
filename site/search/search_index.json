{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"blueprintx documentation \u00b6 Lightweight scaffolding (Make + bash) with ready-to-code Python skeletons. Use these pages to understand what each scaffold gives you and how to extend it with the intended layering. Scaffolds covered \u00b6 Hex Service: hex/DDD-leaning service skeleton with per-feature modules and shared infrastructure. See Hex Service . Lib Minimal: lean library starter with packaging, tests, and CI ready. See Lib Minimal . View these docs locally (Poetry) \u00b6 Add mkdocs to the docs group: poetry add --group docs mkdocs Serve locally: poetry run mkdocs serve -a 0.0.0.0:8000 Build static site: poetry run mkdocs build Scaffolder quick reference \u00b6 Interactive menu: make init Preview structures: make preview Temp sandbox: make dev or make dev-clean Structure-only preview: make dry-run Each scaffold copies shared Python assets from templates/python-common (pyproject, pre-commit, VS Code, CI, README boilerplate) and then applies its template-specific layout.","title":"Home"},{"location":"#blueprintx-documentation","text":"Lightweight scaffolding (Make + bash) with ready-to-code Python skeletons. Use these pages to understand what each scaffold gives you and how to extend it with the intended layering.","title":"blueprintx documentation"},{"location":"#scaffolds-covered","text":"Hex Service: hex/DDD-leaning service skeleton with per-feature modules and shared infrastructure. See Hex Service . Lib Minimal: lean library starter with packaging, tests, and CI ready. See Lib Minimal .","title":"Scaffolds covered"},{"location":"#view-these-docs-locally-poetry","text":"Add mkdocs to the docs group: poetry add --group docs mkdocs Serve locally: poetry run mkdocs serve -a 0.0.0.0:8000 Build static site: poetry run mkdocs build","title":"View these docs locally (Poetry)"},{"location":"#scaffolder-quick-reference","text":"Interactive menu: make init Preview structures: make preview Temp sandbox: make dev or make dev-clean Structure-only preview: make dry-run Each scaffold copies shared Python assets from templates/python-common (pyproject, pre-commit, VS Code, CI, README boilerplate) and then applies its template-specific layout.","title":"Scaffolder quick reference"},{"location":"hex-service/","text":"Hex Service (hex/DDD-flavored Python) \u00b6 A pragmatic, per-feature layout that keeps business logic isolated from I/O while allowing shared infrastructure when it is truly cross-cutting. Expected layout (after scaffold) \u00b6 project/ src/ core/{domain,infrastructure,services} modules/<feature>/{domain,services,infrastructure} utils/ config/ main.py tests/{unit,integration,performance}/ container/ bin/ data/ docs/ public/ .github/workflows/ .vscode/ .env pyproject.toml Domain (core/domain or modules/ /domain) \u00b6 What goes here: Entities, value objects, domain services (pure business logic), and the ports (interfaces) the domain needs. No framework or I/O. Example entity: templates/hex-service/src/modules/example_feature/domain/entities.py from dataclasses import dataclass from datetime import datetime @dataclass class Note: id: str title: str created_at: datetime Example port: templates/hex-service/src/modules/example_feature/domain/ports.py from abc import ABC, abstractmethod from typing import Iterable from .entities import Note class NoteRepository(ABC): @abstractmethod def add(self, note: Note) -> Note: ... @abstractmethod def get(self, note_id: str) -> Note | None: ... @abstractmethod def list(self) -> Iterable[Note]: ... Application/Services (core/services or modules/ /services) \u00b6 What goes here: Use-case orchestration; coordinates domain objects and ports. Enforces transaction boundaries and policies; still framework-free. Example use-case: templates/hex-service/src/modules/example_feature/services/use_cases.py from datetime import datetime import uuid from ..domain.entities import Note from ..domain.ports import NoteRepository class CreateNote: def __init__(self, repo: NoteRepository): self.repo = repo def execute(self, title: str) -> Note: note = Note(id=uuid.uuid4().hex, title=title, created_at=datetime.utcnow()) return self.repo.add(note) Infrastructure (core/infrastructure or modules/ /infrastructure) \u00b6 What goes here: Adapters implementing ports (DB, HTTP clients, brokers), configuration glue, persistence mappers. Keep side effects here. Example adapter implementing the repository port: templates/hex-service/src/modules/example_feature/infrastructure/repositories.py from ..domain.entities import Note from ..domain.ports import NoteRepository class InMemoryNoteRepository(NoteRepository): def __init__(self): self._items: dict[str, Note] = {} def add(self, note: Note) -> Note: self._items[note.id] = note return note Shared database backends live under core/infrastructure/database/ , with runtime selection handled in templates/hex-service/src/main.py using DB_BACKEND (json, csv, sqlite, postgresql, mariadb, mysql). Modules (modules/ ) \u00b6 What goes here: Feature/bounded-context composition\u2014wire domain + app + infra for that feature. Also entrypoints like API/CLI handlers. Example wiring and handler sketch: # composition repo = InMemoryNoteRepository() create_note = CreateNote(repo) list_notes = ListNotes(repo) # API handler (FastAPI-style example) from fastapi import APIRouter router = APIRouter() @router.post(\"/notes\") def create_note_endpoint(payload: CreateNotePayload): note = create_note.execute(title=payload.title) return {\"id\": note.id, \"title\": note.title, \"created_at\": note.created_at.isoformat()} Rules of thumb \u00b6 Domain: pure logic and contracts; no I/O or frameworks. Services/App: orchestrate use-cases, transactions, and policies; still framework-free. Infrastructure: all I/O adapters implementing ports (DB, HTTP, queues, files). Modules: group everything per feature/context and provide entrypoints/wiring. Keep core only for truly shared cross-cutting pieces. Minimal end-to-end demo (in-memory) \u00b6 repo = InMemoryNoteRepository() create_note = CreateNote(repo) list_notes = ListNotes(repo) create_note.execute(\"First note\") print(list_notes.execute())","title":"Hex Service"},{"location":"hex-service/#hex-service-hexddd-flavored-python","text":"A pragmatic, per-feature layout that keeps business logic isolated from I/O while allowing shared infrastructure when it is truly cross-cutting.","title":"Hex Service (hex/DDD-flavored Python)"},{"location":"hex-service/#expected-layout-after-scaffold","text":"project/ src/ core/{domain,infrastructure,services} modules/<feature>/{domain,services,infrastructure} utils/ config/ main.py tests/{unit,integration,performance}/ container/ bin/ data/ docs/ public/ .github/workflows/ .vscode/ .env pyproject.toml","title":"Expected layout (after scaffold)"},{"location":"hex-service/#domain-coredomain-or-modulesdomain","text":"What goes here: Entities, value objects, domain services (pure business logic), and the ports (interfaces) the domain needs. No framework or I/O. Example entity: templates/hex-service/src/modules/example_feature/domain/entities.py from dataclasses import dataclass from datetime import datetime @dataclass class Note: id: str title: str created_at: datetime Example port: templates/hex-service/src/modules/example_feature/domain/ports.py from abc import ABC, abstractmethod from typing import Iterable from .entities import Note class NoteRepository(ABC): @abstractmethod def add(self, note: Note) -> Note: ... @abstractmethod def get(self, note_id: str) -> Note | None: ... @abstractmethod def list(self) -> Iterable[Note]: ...","title":"Domain (core/domain or modules//domain)"},{"location":"hex-service/#applicationservices-coreservices-or-modulesservices","text":"What goes here: Use-case orchestration; coordinates domain objects and ports. Enforces transaction boundaries and policies; still framework-free. Example use-case: templates/hex-service/src/modules/example_feature/services/use_cases.py from datetime import datetime import uuid from ..domain.entities import Note from ..domain.ports import NoteRepository class CreateNote: def __init__(self, repo: NoteRepository): self.repo = repo def execute(self, title: str) -> Note: note = Note(id=uuid.uuid4().hex, title=title, created_at=datetime.utcnow()) return self.repo.add(note)","title":"Application/Services (core/services or modules//services)"},{"location":"hex-service/#infrastructure-coreinfrastructure-or-modulesinfrastructure","text":"What goes here: Adapters implementing ports (DB, HTTP clients, brokers), configuration glue, persistence mappers. Keep side effects here. Example adapter implementing the repository port: templates/hex-service/src/modules/example_feature/infrastructure/repositories.py from ..domain.entities import Note from ..domain.ports import NoteRepository class InMemoryNoteRepository(NoteRepository): def __init__(self): self._items: dict[str, Note] = {} def add(self, note: Note) -> Note: self._items[note.id] = note return note Shared database backends live under core/infrastructure/database/ , with runtime selection handled in templates/hex-service/src/main.py using DB_BACKEND (json, csv, sqlite, postgresql, mariadb, mysql).","title":"Infrastructure (core/infrastructure or modules//infrastructure)"},{"location":"hex-service/#modules-modules","text":"What goes here: Feature/bounded-context composition\u2014wire domain + app + infra for that feature. Also entrypoints like API/CLI handlers. Example wiring and handler sketch: # composition repo = InMemoryNoteRepository() create_note = CreateNote(repo) list_notes = ListNotes(repo) # API handler (FastAPI-style example) from fastapi import APIRouter router = APIRouter() @router.post(\"/notes\") def create_note_endpoint(payload: CreateNotePayload): note = create_note.execute(title=payload.title) return {\"id\": note.id, \"title\": note.title, \"created_at\": note.created_at.isoformat()}","title":"Modules (modules/)"},{"location":"hex-service/#rules-of-thumb","text":"Domain: pure logic and contracts; no I/O or frameworks. Services/App: orchestrate use-cases, transactions, and policies; still framework-free. Infrastructure: all I/O adapters implementing ports (DB, HTTP, queues, files). Modules: group everything per feature/context and provide entrypoints/wiring. Keep core only for truly shared cross-cutting pieces.","title":"Rules of thumb"},{"location":"hex-service/#minimal-end-to-end-demo-in-memory","text":"repo = InMemoryNoteRepository() create_note = CreateNote(repo) list_notes = ListNotes(repo) create_note.execute(\"First note\") print(list_notes.execute())","title":"Minimal end-to-end demo (in-memory)"},{"location":"lib-minimal/","text":"Lib Minimal (library starter) \u00b6 A lean Python library skeleton with packaging, testing, CI, and editor settings ready to go. Expected layout (after scaffold) \u00b6 project/ src/<project_name>/ __init__.py main.py tests/ unit/test_main.py integration/ performance/ docs/ container/ bin/ .github/workflows/tests.yaml .vscode/settings.json .env pyproject.toml README.md Shared Python assets (pyproject, pre-commit, README boilerplate, VS Code, CI) come from templates/python-common . Purpose of each folder \u00b6 src/<project_name> : your library code. The scaffold seeds main.py with a tiny entrypoint. tests/unit : fast tests; scaffold adds a sample test_main.py that invokes the entrypoint. tests/integration and tests/performance : reserved for slower suites. docs : place project documentation (a starter docs/index.md is created). container and bin : optional CLI and container tooling. .github/workflows : CI pipeline (pytest + lint hooks once you add tools). .vscode : sensible editor defaults for Python projects. Starting points \u00b6 Sample entrypoint: templates/lib-minimal/main.py def main(): print(\"Hello from lib-minimal!\") The generated tests/unit/test_main.py asserts that this output appears. Typical workflow \u00b6 Add library functions/classes under src/<project_name>/ . Add or expand tests in tests/unit/ (and integration/performance as needed). Run tests with Poetry: poetry run pytest . Keep the docs ( docs/ ) in sync with public APIs; you can host them with mkdocs like the blueprintx docs. Example feature addition \u00b6 # src/<project_name>/math_utils.py def add(a: int, b: int) -> int: return a + b # tests/unit/test_math_utils.py from <project_name>.math_utils import add def test_add(): assert add(2, 3) == 5","title":"Lib Minimal"},{"location":"lib-minimal/#lib-minimal-library-starter","text":"A lean Python library skeleton with packaging, testing, CI, and editor settings ready to go.","title":"Lib Minimal (library starter)"},{"location":"lib-minimal/#expected-layout-after-scaffold","text":"project/ src/<project_name>/ __init__.py main.py tests/ unit/test_main.py integration/ performance/ docs/ container/ bin/ .github/workflows/tests.yaml .vscode/settings.json .env pyproject.toml README.md Shared Python assets (pyproject, pre-commit, README boilerplate, VS Code, CI) come from templates/python-common .","title":"Expected layout (after scaffold)"},{"location":"lib-minimal/#purpose-of-each-folder","text":"src/<project_name> : your library code. The scaffold seeds main.py with a tiny entrypoint. tests/unit : fast tests; scaffold adds a sample test_main.py that invokes the entrypoint. tests/integration and tests/performance : reserved for slower suites. docs : place project documentation (a starter docs/index.md is created). container and bin : optional CLI and container tooling. .github/workflows : CI pipeline (pytest + lint hooks once you add tools). .vscode : sensible editor defaults for Python projects.","title":"Purpose of each folder"},{"location":"lib-minimal/#starting-points","text":"Sample entrypoint: templates/lib-minimal/main.py def main(): print(\"Hello from lib-minimal!\") The generated tests/unit/test_main.py asserts that this output appears.","title":"Starting points"},{"location":"lib-minimal/#typical-workflow","text":"Add library functions/classes under src/<project_name>/ . Add or expand tests in tests/unit/ (and integration/performance as needed). Run tests with Poetry: poetry run pytest . Keep the docs ( docs/ ) in sync with public APIs; you can host them with mkdocs like the blueprintx docs.","title":"Typical workflow"},{"location":"lib-minimal/#example-feature-addition","text":"# src/<project_name>/math_utils.py def add(a: int, b: int) -> int: return a + b # tests/unit/test_math_utils.py from <project_name>.math_utils import add def test_add(): assert add(2, 3) == 5","title":"Example feature addition"}]}