name: Run Tests

on:
  workflow_call:
    outputs:
      ready_for_release:
        description: "Whether all tests passed successfully"
        value: ${{ jobs.test.result == 'success' }}
  workflow_dispatch:
  pull_request:
    branches:
      - main
  push:
    tags:
      - "v[0-9]+.[0-9]+.[0-9]+"
      - "v[0-9]+.[0-9]+.[0-9]+a[0-9]+"
      - "v[0-9]+.[0-9]+.[0-9]+b[0-9]+"
      - "v[0-9]+.[0-9]+.[0-9]+rc[0-9]+"

jobs:
  test:
    name: Run Automated Tests
    runs-on: ubuntu-24.04
    strategy:
      matrix:
        python-version: ["3.9.22", "3.10.17", "3.11.12", "3.12.8"]
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set Up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Poetry
        uses: snok/install-poetry@v1
        with:
          virtualenvs-in-project: true
          virtualenvs-create: true
          version: 2.1.2

      - name: Load Cached Virtual Environment
        id: cached-venv
        uses: actions/cache@v3
        with:
          path: |
            .venv
            poetry.lock
          key: venv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('pyproject.toml') }}

      - name: Install Dependencies
        if: steps.cached-venv.outputs.cache-hit != 'true'
        run: |
          # Temporary pyproject without Windows platform-specific dependencies
          cp pyproject.toml pyproject.original.toml
          cat pyproject.original.toml | python -c '
          import sys, re
          content = sys.stdin.read()
          content = re.sub(r".*platform\s*=\s*\"win32\".*", "", content)
          content = re.sub(r"pywin32\s*=.*\n", "", content)
          print(content)
          ' > pyproject.toml

          # Regenerate lock file, if needed
          if ! poetry check --lock; then
            echo "Lock file is outdated, regenerating..."
            rm -f poetry.lock
            poetry lock --no-cache
          fi

          echo "No groups to exclude, installing all dependencies"
          poetry install --no-interaction --no-root

          # Restore original pyproject.toml
          mv pyproject.original.toml pyproject.toml
          poetry env activate

      - name: Run Spell Check (codespell)
        run: |
          poetry run codespell .
          if [ $? -ne 0 ]; then
            echo "Typos found! Run 'codespell .' locally to see them."
            exit 1
          fi

      - name: Run Docstring Type Consistency Check
        run: |
          poetry run pydocstyle --convention=numpy --select=D412,D417,DAR stpstone/ tests/

          cat << 'EOF' > check_consistency.py
          import ast
          import sys
          import re
          from typing import Any, Dict, Set

          def compare_types(hint: Any, doc: str) -> bool:
              if hint is Any or doc.lower() == "any":
                  return True
              hint_str = str(hint).replace("typing.", "").lower()
              doc = doc.lower().strip()
              equivalences = {
                  "list": "sequence",
                  "dict": "mapping",
                  "np.ndarray": "ndarray",
                  "numpy.ndarray": "ndarray"
              }
              for k, v in equivalences.items():
                  hint_str = hint_str.replace(k.lower(), v)
                  doc = doc.replace(k.lower(), v)
              return hint_str == doc

          def parse_raises_section(docstring: str) -> Dict[str, str]:
              raises = {}
              if not docstring:
                  return raises
              lines = [line.rstrip() for line in docstring.splitlines()]
              in_raises = False
              for i, line in enumerate(lines):
                  stripped = line.strip()
                  if re.match(r"^(Raises|Raises:)$", stripped, re.IGNORECASE):
                      in_raises = True
                      continue
                  if in_raises:
                      if not stripped:
                          continue
                      if re.match(r"^(Args|Arguments|Parameters|Returns|Yields|Notes|Examples|Attributes|See Also|References)(:)?$", stripped, re.IGNORECASE):
                          break
                      match = re.match(r"^([\w.]+)\s*:\s*(.*)", stripped)
                      if match:
                          exc, desc = match.groups()
                          raises[exc.strip()] = desc.strip()
                      else:
                          match = re.match(r"^([\w.]+)$", stripped)
                          if match:
                              raises[match.group(1)] = ""
              return raises

          def get_actual_raises(node: ast.AST) -> Set[str]:
              raises = set()
              for n in ast.walk(node):
                  if isinstance(n, ast.Raise) and n.exc is not None:
                      if isinstance(n.exc, ast.Name):
                          raises.add(n.exc.id)
                      elif isinstance(n.exc, ast.Call) and isinstance(n.exc.func, ast.Name):
                          raises.add(n.exc.func.id)
                      elif isinstance(n.exc, ast.Attribute):
                          raises.add(n.exc.attr)
                      elif isinstance(n.exc, ast.Call) and hasattr(n.exc.func, 'id'):
                          raises.add(n.exc.func.id)
              return raises

          def normalize_exception_name(name: str) -> str:
              return name.split('.')[-1]

          def check_file(filepath: str) -> int:
              errors = 0
              with open(filepath, 'r') as f:
                  tree = ast.parse(f.read(), filename=filepath)
              for node in ast.walk(tree):
                  if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                      lineno = node.lineno
                      if not node.returns and not any(isinstance(d, ast.Name) and d.id == 'property' for d in node.decorator_list):
                          continue
                      docstring = ast.get_docstring(node)
                      if not docstring:
                          print(f"⚠️  Missing docstring in {node.name}() at line {lineno}")
                          errors += 1
                          continue
                      if node.returns:
                          returns = ast.unparse(node.returns)
                          if "Returns" in docstring or "returns" in docstring:
                              doc_lines = [l.rstrip() for l in docstring.split('\n')]
                              found_return = False
                              for i, line in enumerate(doc_lines):
                                  if line.strip().lower() == "returns":
                                      j = i + 1
                                      while j < len(doc_lines) and set(doc_lines[j].strip()) <= {"-", " "}:
                                          j += 1
                                      while j < len(doc_lines):
                                          candidate = doc_lines[j].strip()
                                          if candidate:
                                              doc_type = candidate
                                              if not compare_types(returns, doc_type):
                                                  print(f"❌ Return type mismatch in {node.name}() at line {lineno}:")
                                                  print(f"   Type hint: {returns}")
                                                  print(f"   Docstring: {doc_type}")
                                                  errors += 1
                                              found_return = True
                                              break
                                          j += 1
                                      break
                              if not found_return:
                                  print(f"⚠️  Return type documented but no type hint in {node.name}() at line {lineno}")
                                  errors += 1
                      for arg in node.args.args:
                          if arg.arg == 'self':
                              continue
                          if arg.annotation:
                              hint = ast.unparse(arg.annotation)
                              arg_doc_found = False
                              for line in docstring.split('\n'):
                                  if arg.arg in line and ":" in line:
                                      doc_type = line.split(":")[1].strip()
                                      if not compare_types(hint, doc_type):
                                          print(f"❌ Parameter type mismatch in {node.name}({arg.arg}) at line {lineno}:")
                                          print(f"   Type hint: {hint}")
                                          print(f"   Docstring: {doc_type}")
                                          errors += 1
                                      arg_doc_found = True
                                      break
                              if not arg_doc_found:
                                  print(f"⚠️  Missing docstring for parameter {arg.arg} in {node.name}() at line {lineno}")
                                  errors += 1
                      doc_raises = parse_raises_section(docstring)
                      actual_raises = get_actual_raises(node)
                      doc_exceptions = {normalize_exception_name(e) for e in doc_raises}
                      actual_exceptions = {normalize_exception_name(e) for e in actual_raises}
                      for exc in doc_exceptions:
                          if exc not in actual_exceptions:
                              print(f"⚠️  Documented but not raised exception {exc} in {node.name}() at line {lineno}")
                              errors += 1
                      for exc in actual_exceptions:
                          if exc not in doc_exceptions:
                              print(f"⚠️  Raised but not documented exception {exc} in {node.name}() at line {lineno}")
                              errors += 1
              return errors

          if __name__ == "__main__":
              import pathlib
              targets = list(pathlib.Path("stpstone").rglob("*.py")) + list(pathlib.Path("tests").rglob("*.py"))
              total_errors = 0
              for path in targets:
                  total_errors += check_file(str(path))
              sys.exit(1 if total_errors > 0 else 0)
          EOF

          poetry run python check_consistency.py

      - name: Run Ruff Linting
        run: |
          poetry run ruff check stpstone/ tests/ --config=ruff.toml
          if [ $? -ne 0 ]; then
            echo "Ruff found issues! Run 'ruff check stpstone/ tests/' locally to see details."
            echo "To fix automatically, run: poetry run ruff check --fix stpstone/ tests/"
            exit 1
          fi

      - name: Run Integration Tests
        run: poetry run pytest tests/integration/ -v

      - name: Run Unit Tests With Coverage
        run: |
          poetry run pytest --cov=stpstone tests/unit/ -v
          poetry run coverage-badge -o coverage.svg -f

      - name: Upload Badge
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge-${{ matrix.python-version }}
          path: coverage.svg